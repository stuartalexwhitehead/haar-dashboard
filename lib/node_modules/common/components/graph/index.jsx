import React from 'react';
import _ from 'lodash';

class Graph extends React.Component {
  static propTypes = {
    dataDescriptor: React.PropTypes.array.isRequired,
    dataPoints: React.PropTypes.array.isRequired,
  };

  static defaultProps = {
    dataDescriptor: [],
    dataPoints: [],
  };

  componentDidMount() {
    const options = this.graphOptions();
    const data = this.graphData();

    if (window.Chart && this._canvas) {
      const context = this._canvas.getContext('2d');
      this._lineGraph = new window.Chart(context) // eslint-disable-line new-cap
        .Scatter(data, options); // eslint-disable-line new-cap
    }
  }

  componentDidUpdate() {
    if (this._canvas) {
      const options = this.graphOptions();
      const data = this.graphData();

      if (window.Chart && this._canvas) {
        const context = this._canvas.getContext('2d');
        this._lineGraph = new window.Chart(context) // eslint-disable-line new-cap
          .Scatter(data, options); // eslint-disable-line new-cap
      }
    }
  }

  graphData = () => {
    const { dataDescriptor, dataPoints } = this.props;

    const colours = [
      '#eb1015',
      '#30ce38',
      '#2457e9',
    ];

    const dataSets = dataDescriptor.map((descriptor, index) => {
      const data = dataPoints.map((dataPoint) => {
        const dataValueForDescriptor = dataPoint.data.reduce((prev, curr) => {
          if (curr.name === descriptor.name) {
            return curr.value;
          }

          return prev;
        }, '');

        return {
          x: new Date(dataPoint.createdAt),
          y: dataValueForDescriptor,
        };
      });

      return {
        label: descriptor.label,
        strokeColor: colours[index % 3],
        pointColor: colours[index % 3],
        data,
      };
    });

    return dataSets;
  }

  graphOptions = () => {
    const { dataDescriptor } = this.props;

    const globalOptions = {
      animation: false,
      showScale: true,
      scaleFontFamily: "'Avenir Next', arial, sans-serif",
      responsive: true,
      maintainAspectRatio: false,
    };

    const labels = dataDescriptor.reduce((arr, descriptor) => {
      if (arr.indexOf(descriptor.unit.shortform) === -1) {
        return arr.concat([descriptor.unit.shortform]);
      }

      return arr;
    }, []);

    const scatterOptions = {
      scaleType: 'date',
      bezierCurve: false,
      useUtc: false,
      scaleShowLabels: labels.length === 1,
      scaleLabel: labels.length === 1 ? `<%=value%>${labels[0]}` : '<%=value%>',
    };

    return _.merge({}, globalOptions, scatterOptions);
  }

  render() {
    this.graphData();
    this.graphOptions();
    return (
      <div>
        <canvas ref={(c) => (this._canvas = c)} width="600" height="400"></canvas>
      </div>
    );
  }
}

export default Graph;
