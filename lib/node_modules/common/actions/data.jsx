import axios from 'axios';
import qs from 'qs';
import _ from 'lodash';
import { browserHistory } from 'react-router';

import { startRequest, endRequest } from 'common/actions/request';
import { addFlash } from 'common/actions/flash';

export function requestDataProducerDevice() {
  return {
    type: 'REQUEST_DATA_PRODUCER_DEVICE',
  };
}

export function receiveDataProducerDevice(json) {
  return {
    type: 'RECEIVE_DATA_PRODUCER_DEVICE',
    device: json.data,
  };
}

export function fetchDataProducerDevice(params) {
  return function fetchDataProducerDeviceThunk(dispatch, getState) {
    const { auth } = getState();
    dispatch(requestDataProducerDevice());
    dispatch(startRequest());

    return axios({
      method: 'get',
      baseURL: process.env.API__URL,
      url: `/devices/${_.get(params, 'segments.device', null)}`,
      headers: {
        'x-access-token': auth.token,
      },
    })
    .then(response => {
      const { data } = response;
      if (data.status !== 'success' || data.data.deviceType.deviceClass === 'output') {
        if (params.res) {
          return params.res.redirect('/dashboard/devices');
        }

        return browserHistory.push('/dashboard/devices');
      }

      dispatch(receiveDataProducerDevice(data));
      dispatch(endRequest());
      return Promise.resolve(data.meta.message);
    }).catch(() => {
      dispatch(endRequest());
      dispatch(addFlash({
        flashType: 'warning',
        message: 'A network error occured',
      }));
    });
  };
}

export function requestDataPoints() {
  return {
    type: 'REQUEST_DATA_POINTS',
  };
}

export function receiveDataPoints(json) {
  return {
    type: 'RECEIVE_DATA_POINTS',
    data: json,
  };
}

export function fetchDataPoints(params) {
  return function fetchDataPointsThunk(dispatch, getState) {
    const { auth, data } = getState();
    dispatch(requestDataPoints());
    dispatch(startRequest());

    const queryParams = _.merge(
      {},
      data.filter,
      {
        page: _.get(params, 'page', null),
      },
      {
        device: _.get(params, 'segments.device', null),
      }
    );

    return axios({
      method: 'get',
      baseURL: process.env.API__URL,
      url: '/data',
      params: queryParams,
      paramsSerializer(axiosParams) {
        return qs.stringify(axiosParams, {
          encode: false,
          allowDots: true,
        });
      },
      headers: {
        'x-access-token': auth.token,
      },
    })
    .then(response => {
      if (response.data.status !== 'success') {
        dispatch(addFlash({
          flashType: 'warning',
          message: response.data.meta.message,
        }));

        return dispatch(endRequest());
      }

      dispatch(receiveDataPoints(response.data));
      dispatch(endRequest());
      return Promise.resolve(response.data.meta.message);
    }).catch(() => {
      dispatch(endRequest());
      dispatch(addFlash({
        flashType: 'warning',
        message: 'A network error occured',
      }));
    });
  };
}

export function clearDataProducerDevice() {
  return {
    type: 'CLEAR_DATA_PRODUCER_DEVICE',
  };
}

export function clearDataPoints() {
  return {
    type: 'CLEAR_DATA_POINTS',
  };
}

export function clearDataPointsFilter() {
  return {
    type: 'CLEAR_DATA_POINTS_FILTER',
  };
}

export function filterDataPoints(params) {
  return {
    type: 'FILTER_DATA_POINTS',
    filter: params.filter,
  };
}

export function sensorStreamSubscribed(handler) {
  return {
    type: 'SENSOR_STREAM_SUBSCRIBED',
    handler,
  };
}

export function sensorStreamUnsubscribed() {
  return {
    type: 'SENSOR_STREAM_UNSUBSCRIBED',
  };
}

export function addSensorDataPoint(dataPoint) {
  return {
    type: 'ADD_SENSOR_DATA_POINT',
    dataPoint,
  };
}

export function subscribeToSensorStream() {
  return function subscribeToSensorStreamThunk(dispatch, getState) {
    const { realtime, data } = getState();

    function eventHandler(dataPoint) {
      dispatch(addSensorDataPoint(dataPoint.payload));
    }

    realtime.connection.writeAndWait({
      room: `input:stream:${data.device._id}`,
      action: 'subscribe',
    }, () => {
      realtime.connection.on('data', eventHandler);
      dispatch(clearDataPoints());
      dispatch(clearDataPointsFilter());
      dispatch(sensorStreamSubscribed(eventHandler));
    });
  };
}

export function unsubscribeFromSensorStream() {
  return function unsubscribeFromSensorStreamThunk(dispatch, getState) {
    const { realtime, data } = getState();

    realtime.connection.removeListener('data', data.realtime.handler);
    dispatch(sensorStreamUnsubscribed());
  };
}
